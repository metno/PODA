package port

import (
	"errors"
	"strconv"
	"time"

	"github.com/rickb777/period"

	"migrate/kdvh/db"
	"migrate/kdvh/import/cache"
	"migrate/lard"
)

// The following ConvertFunctions try to recover the original pair of `controlinfo`
// and `useinfo` generated by Kvalobs for an observation, based on `Obs.Flags` and `Obs.Data`
// Different KDVH tables need different ways to perform this conversion (defined in CONV_MAP).
//
// It returns three structs for each of the lard tables we are inserting into
type ConvertFunction func(KdvhObs) (lard.DataObs, lard.TextObs, lard.Flag, error)

func getConvertFunc(table *db.Table) ConvertFunction {
	switch table.TableName {
	case "T_EDATA":
		return ConvertEdata
	case "T_PDATA":
		return ConvertPdata
	case "T_NDATA":
		return ConvertNdata
	case "T_VDATA":
		return ConvertVdata
	case "T_MONTH", "T_DIURNAL", "T_HOMOGEN_DIURNAL", "T_HOMOGEN_MONTH":
		return ConvertProduct
	case "T_DIURNAL_INTERPOLATED":
		return ConvertDiurnalInterpolated
	}
	return Convert
}

type KdvhObs struct {
	*cache.TsInfo
	obstime time.Time
	data    string
	flags   string
}

// Work around to return reference to consts
func addr[T any](t T) *T {
	return &t
}

func (obs *KdvhObs) flagsAreValid() bool {
	if len(obs.flags) != 5 {
		return false
	}
	_, err := strconv.ParseInt(obs.flags, 10, 32)
	return err == nil
}

func (obs *KdvhObs) Useinfo() *string {
	if !obs.flagsAreValid() {
		return addr(INVALID_FLAGS)
	}
	return addr(obs.flags + DELAY_DEFAULT)
}

// Default ConvertFunction
// NOTE: this should be the only function that can return `lard.TextObs` with non-null text data.
func Convert(obs KdvhObs) (lard.DataObs, lard.TextObs, lard.Flag, error) {
	var valPtr *float32

	controlinfo := VALUE_PASSED_QC
	if obs.data == "" {
		controlinfo = VALUE_MISSING
	}

	val, err := strconv.ParseFloat(obs.data, 32)
	if err == nil {
		valPtr = addr(float32(val))
	}

	return lard.DataObs{
			Id:      obs.Id,
			Obstime: obs.obstime,
			Data:    valPtr,
		},
		lard.TextObs{
			Id:      obs.Id,
			Obstime: obs.obstime,
			Text:    &obs.data,
		},
		lard.Flag{
			Id:          obs.Id,
			Obstime:     obs.obstime,
			Original:    valPtr,
			Corrected:   valPtr,
			Controlinfo: &controlinfo,
			Useinfo:     obs.Useinfo(),
		}, nil
}

// This function modifies obstimes to always use totime
// This is needed because KDVH used incorrect and incosistent timestamps
func ConvertProduct(obs KdvhObs) (lard.DataObs, lard.TextObs, lard.Flag, error) {
	data, text, flag, err := Convert(obs)
	if !obs.Offset.IsZero() {
		if temp, ok := obs.Offset.AddTo(data.Obstime); ok {
			data.Obstime = temp
			text.Obstime = temp
			flag.Obstime = temp
		}
	}
	return data, text, flag, err
}

func ConvertEdata(obs KdvhObs) (lard.DataObs, lard.TextObs, lard.Flag, error) {
	var controlinfo string
	var valPtr *float32

	if val, err := strconv.ParseFloat(obs.data, 32); err != nil {
		switch obs.flags {
		case "70381", "70389", "90989":
			controlinfo = VALUE_REMOVED_BY_QC
		default:
			// Includes "70000", "70101", "99999"
			controlinfo = VALUE_MISSING
		}
	} else {
		controlinfo = VALUE_PASSED_QC
		valPtr = addr(float32(val))
	}

	return lard.DataObs{
			Id:      obs.Id,
			Obstime: obs.obstime,
			Data:    valPtr,
		},
		lard.TextObs{
			Id:      obs.Id,
			Obstime: obs.obstime,
			Text:    &obs.data,
		},
		lard.Flag{
			Id:          obs.Id,
			Obstime:     obs.obstime,
			Original:    valPtr,
			Corrected:   valPtr,
			Controlinfo: &controlinfo,
			Useinfo:     obs.Useinfo(),
		}, nil
}

func ConvertPdata(obs KdvhObs) (lard.DataObs, lard.TextObs, lard.Flag, error) {
	var controlinfo string
	var valPtr *float32

	if val, err := strconv.ParseFloat(obs.data, 32); err != nil {
		switch obs.flags {
		case "20389", "30389", "40389", "50383", "70381", "71381":
			controlinfo = VALUE_REMOVED_BY_QC
		default:
			// "00000", "10000", "10319", "30000", "30319",
			// "40000", "40929", "48929", "48999", "50000",
			// "50205", "60000", "70000", "70103", "70203",
			// "71000", "71203", "90909", "99999"
			controlinfo = VALUE_MISSING
		}
	} else {
		valPtr = addr(float32(val))

		switch obs.flags {
		case "10319", "10329", "30319", "40319", "48929", "48999":
			controlinfo = VALUE_MANUALLY_INTERPOLATED
		case "20389", "30389", "40389", "50383", "70381", "71381", "99319":
			controlinfo = VALUE_CORRECTED_AUTOMATICALLY
		case "40929":
			controlinfo = INTERPOLATION_ADDED_MANUALLY
		default:
			// "71000", "71203", "90909", "99999"
			controlinfo = VALUE_PASSED_QC
		}
	}

	return lard.DataObs{
			Id:      obs.Id,
			Obstime: obs.obstime,
			Data:    valPtr,
		},
		lard.TextObs{
			Id:      obs.Id,
			Obstime: obs.obstime,
			Text:    &obs.data,
		},
		lard.Flag{
			Id:          obs.Id,
			Obstime:     obs.obstime,
			Original:    valPtr,
			Corrected:   valPtr,
			Controlinfo: &controlinfo,
			Useinfo:     obs.Useinfo(),
		}, nil
}

func ConvertNdata(obs KdvhObs) (lard.DataObs, lard.TextObs, lard.Flag, error) {
	var controlinfo string
	var valPtr *float32

	if val, err := strconv.ParseFloat(obs.data, 32); err != nil {
		switch obs.flags {
		case "70389":
			controlinfo = VALUE_REMOVED_BY_QC
		default:
			// "30319", "38929", "40000", "40100", "40315"
			// "40319", "43325", "48325", "49225", "49915"
			// "70000", "70204", "71000", "73309", "78937"
			// "90909", "93399", "98999", "99999"
			controlinfo = VALUE_MISSING
		}
	} else {
		valPtr = addr(float32(val))

		switch obs.flags {
		case "43325", "48325":
			controlinfo = VALUE_MANUALLY_ASSIGNED
		case "30319", "38929", "40315", "40319":
			controlinfo = VALUE_MANUALLY_INTERPOLATED
		case "49225", "49915":
			controlinfo = INTERPOLATION_ADDED_MANUALLY
		case "70389", "73309", "78937", "93399", "98999":
			controlinfo = VALUE_CORRECTED_AUTOMATICALLY
		default:
			// "40000", "40100", "70000", "70204", "71000", "90909", "99999"
			controlinfo = VALUE_PASSED_QC
		}
	}

	return lard.DataObs{
			Id:      obs.Id,
			Obstime: obs.obstime,
			Data:    valPtr,
		},
		lard.TextObs{
			Id:      obs.Id,
			Obstime: obs.obstime,
			Text:    &obs.data,
		},
		lard.Flag{
			Id:          obs.Id,
			Obstime:     obs.obstime,
			Original:    valPtr,
			Corrected:   valPtr,
			Controlinfo: &controlinfo,
			Useinfo:     obs.Useinfo(),
		}, nil
}

func ConvertVdata(obs KdvhObs) (lard.DataObs, lard.TextObs, lard.Flag, error) {
	var useinfo, controlinfo string
	var valPtr *float32

	// set useinfo based on time
	if h := obs.obstime.Hour(); h == 0 || h == 6 || h == 12 || h == 18 {
		useinfo = COMPLETED_HQC
	} else {
		useinfo = INVALID_FLAGS
	}

	// set data and controlinfo
	if val, err := strconv.ParseFloat(obs.data, 32); err != nil {
		controlinfo = VALUE_MISSING
	} else {
		// super special treatment clause of T_VDATA.OT_24, so it will be the same as in kvalobs
		// add custom offset, because OT_24 in KDVH has been treated differently than OT_24 in kvalobs
		if obs.Element == "OT_24" {
			offset, err := period.Parse("PT18H") // fromtime_offset -PT6H, timespan P1D
			if err != nil {
				return lard.DataObs{}, lard.TextObs{}, lard.Flag{}, errors.New("could not parse period")
			}
			temp, ok := offset.AddTo(obs.obstime)
			if !ok {
				return lard.DataObs{}, lard.TextObs{}, lard.Flag{}, errors.New("could not add period")
			}

			obs.obstime = temp
			// convert from hours to minutes
			val *= 60.0
		}

		valPtr = addr(float32(val))
		controlinfo = VALUE_PASSED_QC
	}

	return lard.DataObs{
			Id:      obs.Id,
			Obstime: obs.obstime,
			Data:    valPtr,
		},
		lard.TextObs{
			Id:      obs.Id,
			Obstime: obs.obstime,
			Text:    &obs.data,
		},
		lard.Flag{
			Id:          obs.Id,
			Obstime:     obs.obstime,
			Original:    valPtr,
			Corrected:   valPtr,
			Useinfo:     &useinfo,
			Controlinfo: &controlinfo,
		}, nil
}

func ConvertDiurnalInterpolated(obs KdvhObs) (lard.DataObs, lard.TextObs, lard.Flag, error) {
	val, err := strconv.ParseFloat(obs.data, 32)
	if err != nil {
		return lard.DataObs{}, lard.TextObs{}, lard.Flag{}, err
	}
	valPtr := addr(float32(val))
	return lard.DataObs{
			Id:      obs.Id,
			Obstime: obs.obstime,
			Data:    valPtr,
		},
		lard.TextObs{
			Id:      obs.Id,
			Obstime: obs.obstime,
			Text:    &obs.data,
		},
		lard.Flag{
			Id:          obs.Id,
			Obstime:     obs.obstime,
			Original:    valPtr,
			Corrected:   valPtr,
			Useinfo:     addr(DIURNAL_INTERPOLATED_USEINFO),
			Controlinfo: addr(VALUE_MANUALLY_INTERPOLATED),
		}, nil
}
