---
# set up a role and provide suitable entries in pg_hba.conf with the database
# field set to replication

# ensure max_wal_senders is set to a sufficiently large value in the conf file
# (also possibly max_replication_slots?) When running a standby server, you
# must set this parameter to the same or higher value than on the primary
# server. Otherwise, queries will not be allowed in the standby server.

# set wal_keep_size to a value large enough to ensure that WAL segments are not
# recycled too early, or configure a replication slot for the standby? if there
# is a WAL archive accessible to the standby this may not be needed?

# On systems that support the keepalive socket option, setting
# tcp_keepalives_idle, tcp_keepalives_interval and tcp_keepalives_count helps
# the primary promptly notice a broken connection.

# example auth
# Allow the user "foo" from host 192.168.1.100 to connect to the primary
# as a replication standby if the user's password is correctly supplied.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
# host    replication     foo             192.168.1.100/32        md5
- name: Create a new database with name lard
  community.postgresql.postgresql_db:
    name: lard
  become: true
  become_user: postgres

# TODO: why here?
- name: Copy the db folder to the remote
  ansible.builtin.copy:
    src: "{{ playbook_dir }}/../db/"
    dest: "/etc/postgresql/{{ pg_version }}/db/"
    mode: "0755"
  become: true

# TODO: automatically loop over the sql files in order (needs prepending IDs?)
# with_fileglob: "/etc/postgresql/{{ pg_version }}/db/*"
- name: Create schemas and tables in lard
  community.postgresql.postgresql_script:
    db: lard
    path: "/etc/postgresql/{{ pg_version }}/db/{{ item }}"
  become: true
  become_user: postgres
  loop:
    - public.sql
    - labels.sql
    - flags.sql
    - partitions_generated.sql

- name: Connect to lard database, create lard_user
  community.postgresql.postgresql_user:
    db: lard
    name: lard_user
    password: "{{ pg_lard_password }}"
    role_attr_flags: SUPERUSER # not desired, but the privelege granting doesn't seem to work?
  become: true
  become_user: postgres

- name: Configure Postgres
  block:
    # These settings are replicated over

    # Change postgres configuration with postgresql_set
    # writes the given parameter setting to the $PGDATA/postgresql.auto.conf file, which is read in addition to postgresql.conf.
    # https://www.postgresql.org/docs/current/runtime-config-wal.html#GUC-WAL-LEVEL
    - name: Set wal_level parameter
      community.postgresql.postgresql_set:
        name: wal_level
        value: replica
      become: true
      become_user: postgres

    - name: Set hot_standby parameter
      community.postgresql.postgresql_set:
        name: hot_standby
        value: true
      become: true
      become_user: postgres

    - name: Set hot_standby_feedback parameter
      community.postgresql.postgresql_set:
        name: hot_standby_feedback
        value: true
      become: true
      become_user: postgres

    # This actually determine if replication is running
    # If one of the standbys goes down, setting this to 0 temporarily
    # prevents the primary from locking up
    - name: Set max_wal_senders parameter
      community.postgresql.postgresql_set:
        name: max_wal_senders
        value: 10
      become: true
      become_user: postgres

    # needs to be enabled to use pg_rewind
    # https://www.postgresql.org/docs/current/app-pgrewind.html
    # TODO: warning: Restart of postgreSQL is required for settingh wal_log_hints
    - name: Set wal_log_hints parameter
      community.postgresql.postgresql_set:
        name: wal_log_hints
        value: true
      become: true
      become_user: postgres

    # TODO: we are not actively using replication slots right now
    # replication slots:
    #   + Assure replicas stay in sync even after failover, since WALs don't get overwritten (?)
    #   - If replica goes down logs accumulate until it comes back up
    #   - Are not migrated on switchover (but maybe depends on PG version?)
    - name: Set max_replication_slots parameter
      community.postgresql.postgresql_set:
        name: max_replication_slots
        value: 10
      become: true
      become_user: postgres

    # make it SYNCHRONOUS REPLICATION (without the next two settings it would be asynchronous)
    # https://www.postgresql.org/docs/current/runtime-config-replication.html#GUC-SYNCHRONOUS-STANDBY-NAMES
    - name: Set synchronous_standby_names parameter
      community.postgresql.postgresql_set:
        name: synchronous_standby_names
        value: "*" # all the standbys
      become: true
      become_user: postgres

    # https://www.postgresql.org/docs/current/runtime-config-wal.html#GUC-SYNCHRONOUS-COMMIT
    # will not give standby query consistency (tradeoff for better write performance), but will give standby durable commit after OS crash
    # TODO: I feel like it's the opposite?
    - name: Set synchronous_commit parameter
      community.postgresql.postgresql_set:
        name: synchronous_commit
        value: "on"
      become: true
      become_user: postgres

# https://www.repmgr.org/docs/current/quickstart-primary-register.html
- name: Run repmgr to register the primary
  ansible.builtin.command: repmgr primary register -F # only need -F if rerunning
  become: true
  become_user: postgres
  register: register_results
  # changed_when: "'NOTICE: primary node record (ID: 1) registered' in register.stderr_lines"
  changed_when: true

- name: Print out the register_primary_results
  ansible.builtin.debug:
    msg: "repmgr {{ register_results }}"
  tags: never

# make sure these changes take effect
- name: Restart postgres service
  ansible.builtin.systemd_service:
    name: postgresql
    state: restarted
  become: true
